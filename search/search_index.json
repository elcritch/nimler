{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"nimler Nimler is a library for authoring Erlang and Elixir NIFs in the nim programming language. It has mostly complete bindings for Erlang NIF API , and functions for encoding and decoding Erlang terms. Getting started Setup Install nim and elixir $ nim --version # Nim Compiler Version 1.2.0 [Linux: amd64] $ elixir --version # Elixir 1.10.2 (compiled with Erlang/OTP 22) Install nimler $ nimble install nimler Write NIF in nim This example will create a NIF for Elixir to add two signed 32-bit ints. nif.nim import nimler import nimler / codec func add_numbers ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = let a1 = argv [ 0 ] . decode ( env , int32 ). get ( 0 ) let a2 = argv [ 1 ] . decode ( env , int32 ). get ( 0 ) result = ( a1 + a2 ). encode ( env ) export_nifs ( \"Elixir.NumberAdder\" , [ ( \"add_numbers\" , 2 , add_numbers ) ] ) Note env: ptr ErlNifEnv an untraced pointer to ErlNifEnv struct. This is used during most interactions with Erlang NIF API argc: cint count of arguments argv: ErlNifArgs array of arguments to the NIF. Each element in ErlNifArgs array is an ErlNifTerm export_nifs() compile-time nim template that exports an ErlNifEntry to be loaded by Elixir Compile NIF to shared library nim c --app:lib --noMain --gc:arc -o:nif.so ./nif.nim Note --gc:arc available in nim v1.2 Load NIF from Elixir NumberAdder.exs defmodule NumberAdder do @on_load :load_nif def add_numbers ( _a , _b ), do : raise \"not implemented\" def load_nif , do : :erlang . load_nif ( './nif' , 0 ) end Note add_numbers(_a, _b) Placeholder functions must exist when NIF is loaded. The arity of placeholder functions must also match the arity of functions exported from NIF './nif' path to shared library; in this case nif.so More examples See examples","title":"Introduction"},{"location":"#nimler","text":"Nimler is a library for authoring Erlang and Elixir NIFs in the nim programming language. It has mostly complete bindings for Erlang NIF API , and functions for encoding and decoding Erlang terms.","title":"nimler"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#setup","text":"Install nim and elixir $ nim --version # Nim Compiler Version 1.2.0 [Linux: amd64] $ elixir --version # Elixir 1.10.2 (compiled with Erlang/OTP 22) Install nimler $ nimble install nimler","title":"Setup"},{"location":"#write-nif-in-nim","text":"This example will create a NIF for Elixir to add two signed 32-bit ints. nif.nim import nimler import nimler / codec func add_numbers ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = let a1 = argv [ 0 ] . decode ( env , int32 ). get ( 0 ) let a2 = argv [ 1 ] . decode ( env , int32 ). get ( 0 ) result = ( a1 + a2 ). encode ( env ) export_nifs ( \"Elixir.NumberAdder\" , [ ( \"add_numbers\" , 2 , add_numbers ) ] ) Note env: ptr ErlNifEnv an untraced pointer to ErlNifEnv struct. This is used during most interactions with Erlang NIF API argc: cint count of arguments argv: ErlNifArgs array of arguments to the NIF. Each element in ErlNifArgs array is an ErlNifTerm export_nifs() compile-time nim template that exports an ErlNifEntry to be loaded by Elixir","title":"Write NIF in nim"},{"location":"#compile-nif-to-shared-library","text":"nim c --app:lib --noMain --gc:arc -o:nif.so ./nif.nim Note --gc:arc available in nim v1.2","title":"Compile NIF to shared library"},{"location":"#load-nif-from-elixir","text":"NumberAdder.exs defmodule NumberAdder do @on_load :load_nif def add_numbers ( _a , _b ), do : raise \"not implemented\" def load_nif , do : :erlang . load_nif ( './nif' , 0 ) end Note add_numbers(_a, _b) Placeholder functions must exist when NIF is loaded. The arity of placeholder functions must also match the arity of functions exported from NIF './nif' path to shared library; in this case nif.so","title":"Load NIF from Elixir"},{"location":"#more-examples","text":"See examples","title":"More examples"},{"location":"advanced_use/","text":"Advanced example This example shows rudimentary PI controller . It makes use of \"resource objects,\" and more complex nimler init API. Resource objects The use of resource objects is a safe way to return pointers to native data structures from a NIF. See the section on Resource objects of Erlang NIF docs for more information nif.nim import nimler import . / pi_controller const rate = 100.0 const min = - 10.0 const max = 10.0 const kp = 0.5 const ki = 0.25 const kf = 1.0 type ResourcePriv = object resource_type : ptr ErlNifResourceType proc on_unload ( env : ptr ErlNifEnv , priv_data : pointer ): void = enif_free ( priv_data ) proc on_load ( env : ptr ErlNifEnv , priv_data : ptr pointer , load_info : ErlNifTerm ): cint = let priv = cast [ ptr ResourcePriv ] ( enif_alloc ( cast [ csize_t ] ( sizeof ( ResourcePriv )))) priv . resource_type = enif_open_resource_type ( env , \"PIController\" , ERL_NIF_RT_CREATE ) priv_data [] = priv return 0 proc create_resource ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = let priv = cast [ ptr ResourcePriv ] ( enif_priv_data ( env )) var controller = cast [ ptr PIControl ] ( enif_alloc_resource ( priv . resource_type , cast [ csize_t ] ( sizeof ( PIControl )))) init_controller ( controller , rate , min , max , kp , ki , kf ) var resource_term = enif_make_resource ( env , controller ) enif_release_resource ( controller ) return resource_term proc update_resource ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = let priv = cast [ ptr ResourcePriv ] ( enif_priv_data ( env )) var controller : ptr PIControl if not enif_get_resource ( env , argv [ 0 ] , priv . resource_type , addr ( controller )): return enif_make_badarg ( env ) let sp = argv [ 1 ] . decode ( env , float ). get () let pv = argv [ 2 ] . decode ( env , float ). get () let res = controller . update ( sp , pv ) return ok ( res , env ) const exports = NifOptions ( funcs : @[ create_resource . toNif ( \"create_resource\" , arity = 0 ), update_resource . toNif ( \"update_resource\" , arity = 3 ) ] , load : on_load , unload : on_unload ) export_nifs ( exports ) pi_controller.nim type PIControl * = object kp : float # proportional gain ki : float # integral gain kf : float # feedforward gain p : float # proportional i : float # integral f : float # feedforward r : float # control di : float # integral rate min : float max : float integrate : bool proc init_controller * ( control : ptr PIControl , rate : float , min : float , max : float , kp : float = 0.0 , ki : float = 0.0 , kf : float = 0.0 ) = control . min = min control . max = max control . di = 1.0 / rate control . integrate = true control . kp = kp control . ki = ki control . kf = kf control . p = 0.0 control . i = 0.0 control . f = 0.0 control . r = 0.0 proc set_gain * ( control : ptr PIControl , kp : float , ki : float , kf : float ) = control . kp = kp control . ki = ki control . kf = kf proc clear_gain * ( control : ptr PIControl ) = set_gain ( control , 0.0 , 0.0 , 0.0 ) proc pause_i * ( control : ptr PIControl ) = control . integrate = false proc resume_i * ( control : ptr PIControl ) = control . integrate = true proc update * ( control : ptr PIControl , sp : float , pv : float , f : float = 0.0 ): float = let error = sp - pv control . p = control . kp * error if control . integrate : control . i = control . i + error * control . ki * control . di control . f = control . kf * f control . r = clamp ( control . p + control . i + control . f , control . min , control . max ) result = control . r Controller.exs defmodule PIController do @on_load :load_nif def create_resource (), do : raise \"not implemented\" def update_resource ( _a , _b , _c ), do : raise \"not implemented\" def load_nif do :erlang . load_nif ( to_charlist ( Path . join ( Path . dirname ( __ENV__ . file ), \"nif\" )), 0 ) ctrl = create_resource () IO . inspect ( update_resource ( ctrl , 10.0 , 1.0 ), label : 'PIControl update' ) IO . inspect ( update_resource ( ctrl , 10.0 , 5.0 ), label : 'PIControl update' ) IO . inspect ( update_resource ( ctrl , 10.0 , 8.0 ), label : 'PIControl update' ) end end","title":"Advanced example"},{"location":"advanced_use/#advanced-example","text":"This example shows rudimentary PI controller . It makes use of \"resource objects,\" and more complex nimler init API. Resource objects The use of resource objects is a safe way to return pointers to native data structures from a NIF. See the section on Resource objects of Erlang NIF docs for more information nif.nim import nimler import . / pi_controller const rate = 100.0 const min = - 10.0 const max = 10.0 const kp = 0.5 const ki = 0.25 const kf = 1.0 type ResourcePriv = object resource_type : ptr ErlNifResourceType proc on_unload ( env : ptr ErlNifEnv , priv_data : pointer ): void = enif_free ( priv_data ) proc on_load ( env : ptr ErlNifEnv , priv_data : ptr pointer , load_info : ErlNifTerm ): cint = let priv = cast [ ptr ResourcePriv ] ( enif_alloc ( cast [ csize_t ] ( sizeof ( ResourcePriv )))) priv . resource_type = enif_open_resource_type ( env , \"PIController\" , ERL_NIF_RT_CREATE ) priv_data [] = priv return 0 proc create_resource ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = let priv = cast [ ptr ResourcePriv ] ( enif_priv_data ( env )) var controller = cast [ ptr PIControl ] ( enif_alloc_resource ( priv . resource_type , cast [ csize_t ] ( sizeof ( PIControl )))) init_controller ( controller , rate , min , max , kp , ki , kf ) var resource_term = enif_make_resource ( env , controller ) enif_release_resource ( controller ) return resource_term proc update_resource ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = let priv = cast [ ptr ResourcePriv ] ( enif_priv_data ( env )) var controller : ptr PIControl if not enif_get_resource ( env , argv [ 0 ] , priv . resource_type , addr ( controller )): return enif_make_badarg ( env ) let sp = argv [ 1 ] . decode ( env , float ). get () let pv = argv [ 2 ] . decode ( env , float ). get () let res = controller . update ( sp , pv ) return ok ( res , env ) const exports = NifOptions ( funcs : @[ create_resource . toNif ( \"create_resource\" , arity = 0 ), update_resource . toNif ( \"update_resource\" , arity = 3 ) ] , load : on_load , unload : on_unload ) export_nifs ( exports ) pi_controller.nim type PIControl * = object kp : float # proportional gain ki : float # integral gain kf : float # feedforward gain p : float # proportional i : float # integral f : float # feedforward r : float # control di : float # integral rate min : float max : float integrate : bool proc init_controller * ( control : ptr PIControl , rate : float , min : float , max : float , kp : float = 0.0 , ki : float = 0.0 , kf : float = 0.0 ) = control . min = min control . max = max control . di = 1.0 / rate control . integrate = true control . kp = kp control . ki = ki control . kf = kf control . p = 0.0 control . i = 0.0 control . f = 0.0 control . r = 0.0 proc set_gain * ( control : ptr PIControl , kp : float , ki : float , kf : float ) = control . kp = kp control . ki = ki control . kf = kf proc clear_gain * ( control : ptr PIControl ) = set_gain ( control , 0.0 , 0.0 , 0.0 ) proc pause_i * ( control : ptr PIControl ) = control . integrate = false proc resume_i * ( control : ptr PIControl ) = control . integrate = true proc update * ( control : ptr PIControl , sp : float , pv : float , f : float = 0.0 ): float = let error = sp - pv control . p = control . kp * error if control . integrate : control . i = control . i + error * control . ki * control . di control . f = control . kf * f control . r = clamp ( control . p + control . i + control . f , control . min , control . max ) result = control . r Controller.exs defmodule PIController do @on_load :load_nif def create_resource (), do : raise \"not implemented\" def update_resource ( _a , _b , _c ), do : raise \"not implemented\" def load_nif do :erlang . load_nif ( to_charlist ( Path . join ( Path . dirname ( __ENV__ . file ), \"nif\" )), 0 ) ctrl = create_resource () IO . inspect ( update_resource ( ctrl , 10.0 , 1.0 ), label : 'PIControl update' ) IO . inspect ( update_resource ( ctrl , 10.0 , 5.0 ), label : 'PIControl update' ) IO . inspect ( update_resource ( ctrl , 10.0 , 8.0 ), label : 'PIControl update' ) end end","title":"Advanced example"},{"location":"bindings/","text":"erl_nif API bindings The following bindings are available to nimler NIFs. For more details, see the erl_nif docs . enif_map_iterator_create proc enif_map_iterator_create*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr ErlNifMapIterator; a4: ErlNifMapIteratorEntry): bool enif_map_iterator_destroy proc enif_map_iterator_destroy*(a1: ptr ErlNifEnv; a2: ptr ErlNifMapIterator): void enif_map_iterator_next proc enif_map_iterator_next*(a1: ptr ErlNifEnv; a2: ptr ErlNifMapIterator): bool enif_map_iterator_prev proc enif_map_iterator_prev*(a1: ptr ErlNifEnv; a2: ptr ErlNifMapIterator): bool enif_map_iterator_get_pair proc enif_map_iterator_get_pair*(a1: ptr ErlNifEnv; a2: ptr ErlNifMapIterator; a3: ptr ErlNifTerm; a4: ptr ErlNifTerm): bool enif_map_iterator_is_head proc enif_map_iterator_is_head*(a1: ptr ErlNifEnv; a2: ptr ErlNifMapIterator): bool enif_map_iterator_is_tail proc enif_map_iterator_is_tail*(a1: ptr ErlNifEnv; a2: ptr ErlNifMapIterator): bool enif_snprintf proc enif_snprintf*(a1: ptr char, a2: cuint; a3: cstring): bool enif_fprintf proc enif_fprintf*(a1: File, a2: cstring): bool enif_alloc proc enif_alloc*(a1: csize_t): pointer enif_free proc enif_free*(a1: pointer) enif_realloc proc enif_realloc*(a1: pointer; a2: csize_t): pointer enif_priv_data proc enif_priv_data*(a1: ptr ErlNifEnv): pointer enif_term_type proc enif_term_type*(a1: ptr ErlNifEnv; a2: ErlNifTerm): ErlNifTermType enif_is_process_alive proc enif_is_process_alive*(a1: ptr ErlNifEnv; a2: ptr ErlNifPid): bool enif_is_port_alive proc enif_is_port_alive*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool enif_is_pid_undefined proc enif_is_pid_undefined*(a2: ptr ErlNifPid): bool enif_is_exception proc enif_is_exception*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool enif_is_atom proc enif_is_atom*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool enif_is_binary proc enif_is_binary*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool enif_is_ref proc enif_is_ref*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool enif_is_fun proc enif_is_fun*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool enif_is_pid proc enif_is_pid*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool enif_is_port proc enif_is_port*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool enif_is_identical proc enif_is_identical*(lhs: ErlNifTerm; rhs: ErlNifTerm): bool enif_is_list proc enif_is_list*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool enif_is_tuple proc enif_is_tuple*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool enif_is_empty_list proc enif_is_empty_list*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool enif_is_map proc enif_is_map*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool enif_is_number proc enif_is_number*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool enif_is_current_process_alive proc enif_is_current_process_alive*(a1: ptr ErlNifEnv): bool enif_compare proc enif_compare*(a1: ErlNifTerm; a2: ErlNifTerm): cint enif_inspect_binary proc enif_inspect_binary*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr ErlNifBinary): bool enif_alloc_binary proc enif_alloc_binary*(a1: csize_t; a2: ptr ErlNifBinary): cint enif_realloc_binary proc enif_realloc_binary*(a1: ptr ErlNifBinary; a2: csize_t): cint enif_release_binary proc enif_release_binary*(a1: ptr ErlNifBinary): cint enif_get_atom proc enif_get_atom*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr char; a4: csize_t; a5: ErlNifCharEncoding): cint enif_get_atom_length proc enif_get_atom_length*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr cuint; a4: ErlNifCharEncoding): bool enif_get_int proc enif_get_int*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr cint): bool enif_get_long proc enif_get_long*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr clong): bool enif_get_int64 proc enif_get_int64*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr clonglong): bool enif_get_uint proc enif_get_uint*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr cuint): bool enif_get_ulong proc enif_get_ulong*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr culong): bool enif_get_uint64 proc enif_get_uint64*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr culonglong): bool enif_get_double proc enif_get_double*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr cdouble): bool enif_get_list_cell proc enif_get_list_cell*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr ErlNifTerm; a4: ptr ErlNifTerm): bool enif_get_list_length proc enif_get_list_length*(a1: ptr ErlNifEnv; a2: ErlNifTerm; len: ptr cuint): bool enif_get_tuple proc enif_get_tuple*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr cuint; a4: ptr ptr UncheckedArray[ErlNifTerm]): bool enif_get_string proc enif_get_string*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr char; a4: csize_t; a5: ErlNifCharEncoding): cint enif_make_unique_integer proc enif_make_unique_integer*(a1: ptr ErlNifEnv; a2: ErlNifUniqueInteger): ErlNifTerm enif_make_atom proc enif_make_atom*(a1: ptr ErlNifEnv; a2: cstring): ErlNifTerm enif_make_atom_len proc enif_make_atom_len*(a1: ptr ErlNifEnv; a2: cstring; a3: csize_t): ErlNifTerm enif_make_existing_atom proc enif_make_existing_atom*(a1: ptr ErlNifEnv; a2: cstring; a3: ptr ErlNifTerm; a4: ErlNifCharEncoding): bool enif_make_existing_atom_len proc enif_make_existing_atom_len*(a1: ptr ErlNifEnv; a2: cstring; a3: cuint; a4: ptr ErlNifTerm; a5: ErlNifCharEncoding): bool enif_make_binary proc enif_make_binary*(a1: ptr ErlNifEnv; a2: ptr ErlNifBinary): ErlNifTerm enif_make_sub_binary proc enif_make_sub_binary*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: csize_t; a4: csize_t): ErlNifTerm enif_make_badarg proc enif_make_badarg*(a1: ptr ErlNifEnv): ErlNifTerm enif_make_int proc enif_make_int*(a1: ptr ErlNifEnv; a2: cint): ErlNifTerm enif_make_long proc enif_make_long*(a1: ptr ErlNifEnv; a2: clong): ErlNifTerm enif_make_int64 proc enif_make_int64*(a1: ptr ErlNifEnv; a2: clonglong): ErlNifTerm enif_make_ulong proc enif_make_ulong*(a1: ptr ErlNifEnv; a2: culong): ErlNifTerm enif_make_uint64 proc enif_make_uint64*(a1: ptr ErlNifEnv; a2: culonglong): ErlNifTerm enif_make_double proc enif_make_double*(a1: ptr ErlNifEnv; a2: cdouble): ErlNifTerm enif_make_tuple proc enif_make_tuple*(a1: ptr ErlNifEnv; a2: csize_t): ErlNifTerm enif_make_list proc enif_make_list*(a1: ptr ErlNifEnv; a2: csize_t): ErlNifTerm enif_make_list_cell proc enif_make_list_cell*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ErlNifTerm): ErlNifTerm enif_make_reverse_list proc enif_make_reverse_list*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr ErlNifTerm): bool enif_make_string proc enif_make_string*(a1: ptr ErlNifEnv; string: cstring; a3: ErlNifCharEncoding): ErlNifTerm enif_make_string_len proc enif_make_string_len*(a1: ptr ErlNifEnv; string: cstring; a2: csize_t; a3: ErlNifCharEncoding): ErlNifTerm enif_make_ref proc enif_make_ref*(a1: ptr ErlNifEnv): ErlNifTerm enif_make_uint proc enif_make_uint*(a1: ptr ErlNifEnv; a2: csize_t): ErlNifTerm enif_make_tuple_from_array proc enif_make_tuple_from_array*(a1: ptr ErlNifEnv; a2: openArray[ErlNifTerm]): ErlNifTerm enif_make_list_from_array proc enif_make_list_from_array*(a1: ptr ErlNifEnv; a2: openArray[ErlNifTerm]): ErlNifTerm enif_make_new_binary proc enif_make_new_binary*(a1: ptr ErlNifEnv; a2: csize_t; a3: ptr ErlNifTerm): ptr cuchar enif_system_info proc enif_system_info*(a1: ptr ErlNifSysInfo; a2: csize_t): void enif_system_info proc enif_system_info*(): ErlNifSysInfo enif_raise_exception proc enif_raise_exception*(a1: ptr ErlNifEnv; a2: ErlNifTerm): ErlNifTerm enif_has_pending_exception proc enif_has_pending_exception*(a1: ptr ErlNifEnv; a2: ptr ErlNifTerm): bool enif_has_pending_exception proc enif_has_pending_exception*(a1: ptr ErlNifEnv): bool enif_term_to_binary proc enif_term_to_binary*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr ErlNifBinary): cint enif_binary_to_term proc enif_binary_to_term*(a1: ptr ErlNifEnv; a2: ptr cuchar; a3: csize_t; a4: ptr ErlNifTerm; a5: csize_t): csize_t enif_hash proc enif_hash*(a1: ErlNifHash; term: ErlNifTerm; salt: culonglong = 0): culonglong enif_alloc_env proc enif_alloc_env*(): ptr ErlNifEnv enif_free_env proc enif_free_env*(a1: ptr ErlNifEnv) enif_clear_env proc enif_clear_env*(a1: ptr ErlNifEnv) enif_send proc enif_send*(a1: ptr ErlNifEnv; a2: ptr ErlNifPid; a3: ptr ErlNifEnv; a4: ErlNifTerm): bool enif_make_copy proc enif_make_copy*(a1: ptr ErlNifEnv; a2: ErlNifTerm): ErlNifTerm enif_make_pid proc enif_make_pid*(a1: ptr ErlNifEnv; a2: ptr ErlNifPid): ErlNifTerm enif_self proc enif_self*(a1: ptr ErlNifEnv; a2: ptr ErlNifPid): ptr ErlNifPid enif_get_local_pid proc enif_get_local_pid*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr ErlNifPid): bool enif_get_map_size proc enif_get_map_size*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr cuint): bool enif_make_new_map proc enif_make_new_map*(a1: ptr ErlNifEnv): ErlNifTerm enif_make_map_from_arrays proc enif_make_map_from_arrays*(a1: ptr ErlNifEnv; a2: ptr ErlNifTerm; a3: ptr ErlNifTerm; a4: cuint, a5: ptr ErlNifTerm): bool enif_make_map_put proc enif_make_map_put*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ErlNifTerm; a4: ErlNifTerm; a5: ptr ErlNifTerm): bool enif_get_map_value proc enif_get_map_value*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ErlNifTerm; a4: ptr ErlNifTerm): bool enif_make_map_update proc enif_make_map_update*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ErlNifTerm; a4: ErlNifTerm; a5: ptr ErlNifTerm): bool enif_make_map_remove proc enif_make_map_remove*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ErlNifTerm; a4: ptr ErlNifTerm): bool enif_open_resource_type proc enif_open_resource_type*(a1: ptr ErlNifEnv, a2: typeof(nil); a3: cstring, a4: pointer; a5: ErlNifResourceFlags; a6: ptr ErlNifResourceFlags): ptr ErlNifResourceType enif_open_resource_type proc enif_open_resource_type*(a1: ptr ErlNifEnv; a2: cstring; a3: ErlNifResourceFlags; a4: ptr ErlNifResourceFlags): ptr ErlNifResourceType enif_open_resource_type proc enif_open_resource_type*(a1: ptr ErlNifEnv; a2: cstring; a3: ErlNifResourceFlags): ptr ErlNifResourceType enif_alloc_resource proc enif_alloc_resource*(a1: pointer; a2: csize_t): pointer enif_release_resource proc enif_release_resource*(a1: pointer): void enif_make_resource proc enif_make_resource*(a1: ptr ErlNifEnv; a2: pointer): ErlNifTerm enif_get_resource proc enif_get_resource*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: pointer; a4: pointer): bool enif_consume_timeslice proc enif_consume_timeslice*(a1: ptr ErlNifEnv; a2: cint): bool enif_schedule_nif proc enif_schedule_nif*(a1: ptr ErlNifEnv; a2: cstring; a3: cint; a4: NifFunc; a5: cint; a6: ErlNifArgs): ErlNifTerm enif_schedule_nif proc enif_schedule_nif*(a1: ptr ErlNifEnv; a2: cstring; a3: cint; a4: NifFunc; a5: openArray[ErlNifTerm]): ErlNifTerm enif_schedule_nif proc enif_schedule_nif*(a1: ptr ErlNifEnv; a2: NifFunc; a3: openArray[ErlNifTerm]): ErlNifTerm","title":"erl_nif API"},{"location":"bindings/#erl_nif-api-bindings","text":"The following bindings are available to nimler NIFs. For more details, see the erl_nif docs .","title":"erl_nif API bindings"},{"location":"bindings/#enif_map_iterator_create","text":"proc enif_map_iterator_create*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr ErlNifMapIterator; a4: ErlNifMapIteratorEntry): bool","title":"enif_map_iterator_create"},{"location":"bindings/#enif_map_iterator_destroy","text":"proc enif_map_iterator_destroy*(a1: ptr ErlNifEnv; a2: ptr ErlNifMapIterator): void","title":"enif_map_iterator_destroy"},{"location":"bindings/#enif_map_iterator_next","text":"proc enif_map_iterator_next*(a1: ptr ErlNifEnv; a2: ptr ErlNifMapIterator): bool","title":"enif_map_iterator_next"},{"location":"bindings/#enif_map_iterator_prev","text":"proc enif_map_iterator_prev*(a1: ptr ErlNifEnv; a2: ptr ErlNifMapIterator): bool","title":"enif_map_iterator_prev"},{"location":"bindings/#enif_map_iterator_get_pair","text":"proc enif_map_iterator_get_pair*(a1: ptr ErlNifEnv; a2: ptr ErlNifMapIterator; a3: ptr ErlNifTerm; a4: ptr ErlNifTerm): bool","title":"enif_map_iterator_get_pair"},{"location":"bindings/#enif_map_iterator_is_head","text":"proc enif_map_iterator_is_head*(a1: ptr ErlNifEnv; a2: ptr ErlNifMapIterator): bool","title":"enif_map_iterator_is_head"},{"location":"bindings/#enif_map_iterator_is_tail","text":"proc enif_map_iterator_is_tail*(a1: ptr ErlNifEnv; a2: ptr ErlNifMapIterator): bool","title":"enif_map_iterator_is_tail"},{"location":"bindings/#enif_snprintf","text":"proc enif_snprintf*(a1: ptr char, a2: cuint; a3: cstring): bool","title":"enif_snprintf"},{"location":"bindings/#enif_fprintf","text":"proc enif_fprintf*(a1: File, a2: cstring): bool","title":"enif_fprintf"},{"location":"bindings/#enif_alloc","text":"proc enif_alloc*(a1: csize_t): pointer","title":"enif_alloc"},{"location":"bindings/#enif_free","text":"proc enif_free*(a1: pointer)","title":"enif_free"},{"location":"bindings/#enif_realloc","text":"proc enif_realloc*(a1: pointer; a2: csize_t): pointer","title":"enif_realloc"},{"location":"bindings/#enif_priv_data","text":"proc enif_priv_data*(a1: ptr ErlNifEnv): pointer","title":"enif_priv_data"},{"location":"bindings/#enif_term_type","text":"proc enif_term_type*(a1: ptr ErlNifEnv; a2: ErlNifTerm): ErlNifTermType","title":"enif_term_type"},{"location":"bindings/#enif_is_process_alive","text":"proc enif_is_process_alive*(a1: ptr ErlNifEnv; a2: ptr ErlNifPid): bool","title":"enif_is_process_alive"},{"location":"bindings/#enif_is_port_alive","text":"proc enif_is_port_alive*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool","title":"enif_is_port_alive"},{"location":"bindings/#enif_is_pid_undefined","text":"proc enif_is_pid_undefined*(a2: ptr ErlNifPid): bool","title":"enif_is_pid_undefined"},{"location":"bindings/#enif_is_exception","text":"proc enif_is_exception*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool","title":"enif_is_exception"},{"location":"bindings/#enif_is_atom","text":"proc enif_is_atom*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool","title":"enif_is_atom"},{"location":"bindings/#enif_is_binary","text":"proc enif_is_binary*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool","title":"enif_is_binary"},{"location":"bindings/#enif_is_ref","text":"proc enif_is_ref*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool","title":"enif_is_ref"},{"location":"bindings/#enif_is_fun","text":"proc enif_is_fun*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool","title":"enif_is_fun"},{"location":"bindings/#enif_is_pid","text":"proc enif_is_pid*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool","title":"enif_is_pid"},{"location":"bindings/#enif_is_port","text":"proc enif_is_port*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool","title":"enif_is_port"},{"location":"bindings/#enif_is_identical","text":"proc enif_is_identical*(lhs: ErlNifTerm; rhs: ErlNifTerm): bool","title":"enif_is_identical"},{"location":"bindings/#enif_is_list","text":"proc enif_is_list*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool","title":"enif_is_list"},{"location":"bindings/#enif_is_tuple","text":"proc enif_is_tuple*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool","title":"enif_is_tuple"},{"location":"bindings/#enif_is_empty_list","text":"proc enif_is_empty_list*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool","title":"enif_is_empty_list"},{"location":"bindings/#enif_is_map","text":"proc enif_is_map*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool","title":"enif_is_map"},{"location":"bindings/#enif_is_number","text":"proc enif_is_number*(a1: ptr ErlNifEnv; a2: ErlNifTerm): bool","title":"enif_is_number"},{"location":"bindings/#enif_is_current_process_alive","text":"proc enif_is_current_process_alive*(a1: ptr ErlNifEnv): bool","title":"enif_is_current_process_alive"},{"location":"bindings/#enif_compare","text":"proc enif_compare*(a1: ErlNifTerm; a2: ErlNifTerm): cint","title":"enif_compare"},{"location":"bindings/#enif_inspect_binary","text":"proc enif_inspect_binary*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr ErlNifBinary): bool","title":"enif_inspect_binary"},{"location":"bindings/#enif_alloc_binary","text":"proc enif_alloc_binary*(a1: csize_t; a2: ptr ErlNifBinary): cint","title":"enif_alloc_binary"},{"location":"bindings/#enif_realloc_binary","text":"proc enif_realloc_binary*(a1: ptr ErlNifBinary; a2: csize_t): cint","title":"enif_realloc_binary"},{"location":"bindings/#enif_release_binary","text":"proc enif_release_binary*(a1: ptr ErlNifBinary): cint","title":"enif_release_binary"},{"location":"bindings/#enif_get_atom","text":"proc enif_get_atom*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr char; a4: csize_t; a5: ErlNifCharEncoding): cint","title":"enif_get_atom"},{"location":"bindings/#enif_get_atom_length","text":"proc enif_get_atom_length*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr cuint; a4: ErlNifCharEncoding): bool","title":"enif_get_atom_length"},{"location":"bindings/#enif_get_int","text":"proc enif_get_int*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr cint): bool","title":"enif_get_int"},{"location":"bindings/#enif_get_long","text":"proc enif_get_long*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr clong): bool","title":"enif_get_long"},{"location":"bindings/#enif_get_int64","text":"proc enif_get_int64*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr clonglong): bool","title":"enif_get_int64"},{"location":"bindings/#enif_get_uint","text":"proc enif_get_uint*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr cuint): bool","title":"enif_get_uint"},{"location":"bindings/#enif_get_ulong","text":"proc enif_get_ulong*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr culong): bool","title":"enif_get_ulong"},{"location":"bindings/#enif_get_uint64","text":"proc enif_get_uint64*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr culonglong): bool","title":"enif_get_uint64"},{"location":"bindings/#enif_get_double","text":"proc enif_get_double*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr cdouble): bool","title":"enif_get_double"},{"location":"bindings/#enif_get_list_cell","text":"proc enif_get_list_cell*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr ErlNifTerm; a4: ptr ErlNifTerm): bool","title":"enif_get_list_cell"},{"location":"bindings/#enif_get_list_length","text":"proc enif_get_list_length*(a1: ptr ErlNifEnv; a2: ErlNifTerm; len: ptr cuint): bool","title":"enif_get_list_length"},{"location":"bindings/#enif_get_tuple","text":"proc enif_get_tuple*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr cuint; a4: ptr ptr UncheckedArray[ErlNifTerm]): bool","title":"enif_get_tuple"},{"location":"bindings/#enif_get_string","text":"proc enif_get_string*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr char; a4: csize_t; a5: ErlNifCharEncoding): cint","title":"enif_get_string"},{"location":"bindings/#enif_make_unique_integer","text":"proc enif_make_unique_integer*(a1: ptr ErlNifEnv; a2: ErlNifUniqueInteger): ErlNifTerm","title":"enif_make_unique_integer"},{"location":"bindings/#enif_make_atom","text":"proc enif_make_atom*(a1: ptr ErlNifEnv; a2: cstring): ErlNifTerm","title":"enif_make_atom"},{"location":"bindings/#enif_make_atom_len","text":"proc enif_make_atom_len*(a1: ptr ErlNifEnv; a2: cstring; a3: csize_t): ErlNifTerm","title":"enif_make_atom_len"},{"location":"bindings/#enif_make_existing_atom","text":"proc enif_make_existing_atom*(a1: ptr ErlNifEnv; a2: cstring; a3: ptr ErlNifTerm; a4: ErlNifCharEncoding): bool","title":"enif_make_existing_atom"},{"location":"bindings/#enif_make_existing_atom_len","text":"proc enif_make_existing_atom_len*(a1: ptr ErlNifEnv; a2: cstring; a3: cuint; a4: ptr ErlNifTerm; a5: ErlNifCharEncoding): bool","title":"enif_make_existing_atom_len"},{"location":"bindings/#enif_make_binary","text":"proc enif_make_binary*(a1: ptr ErlNifEnv; a2: ptr ErlNifBinary): ErlNifTerm","title":"enif_make_binary"},{"location":"bindings/#enif_make_sub_binary","text":"proc enif_make_sub_binary*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: csize_t; a4: csize_t): ErlNifTerm","title":"enif_make_sub_binary"},{"location":"bindings/#enif_make_badarg","text":"proc enif_make_badarg*(a1: ptr ErlNifEnv): ErlNifTerm","title":"enif_make_badarg"},{"location":"bindings/#enif_make_int","text":"proc enif_make_int*(a1: ptr ErlNifEnv; a2: cint): ErlNifTerm","title":"enif_make_int"},{"location":"bindings/#enif_make_long","text":"proc enif_make_long*(a1: ptr ErlNifEnv; a2: clong): ErlNifTerm","title":"enif_make_long"},{"location":"bindings/#enif_make_int64","text":"proc enif_make_int64*(a1: ptr ErlNifEnv; a2: clonglong): ErlNifTerm","title":"enif_make_int64"},{"location":"bindings/#enif_make_ulong","text":"proc enif_make_ulong*(a1: ptr ErlNifEnv; a2: culong): ErlNifTerm","title":"enif_make_ulong"},{"location":"bindings/#enif_make_uint64","text":"proc enif_make_uint64*(a1: ptr ErlNifEnv; a2: culonglong): ErlNifTerm","title":"enif_make_uint64"},{"location":"bindings/#enif_make_double","text":"proc enif_make_double*(a1: ptr ErlNifEnv; a2: cdouble): ErlNifTerm","title":"enif_make_double"},{"location":"bindings/#enif_make_tuple","text":"proc enif_make_tuple*(a1: ptr ErlNifEnv; a2: csize_t): ErlNifTerm","title":"enif_make_tuple"},{"location":"bindings/#enif_make_list","text":"proc enif_make_list*(a1: ptr ErlNifEnv; a2: csize_t): ErlNifTerm","title":"enif_make_list"},{"location":"bindings/#enif_make_list_cell","text":"proc enif_make_list_cell*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ErlNifTerm): ErlNifTerm","title":"enif_make_list_cell"},{"location":"bindings/#enif_make_reverse_list","text":"proc enif_make_reverse_list*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr ErlNifTerm): bool","title":"enif_make_reverse_list"},{"location":"bindings/#enif_make_string","text":"proc enif_make_string*(a1: ptr ErlNifEnv; string: cstring; a3: ErlNifCharEncoding): ErlNifTerm","title":"enif_make_string"},{"location":"bindings/#enif_make_string_len","text":"proc enif_make_string_len*(a1: ptr ErlNifEnv; string: cstring; a2: csize_t; a3: ErlNifCharEncoding): ErlNifTerm","title":"enif_make_string_len"},{"location":"bindings/#enif_make_ref","text":"proc enif_make_ref*(a1: ptr ErlNifEnv): ErlNifTerm","title":"enif_make_ref"},{"location":"bindings/#enif_make_uint","text":"proc enif_make_uint*(a1: ptr ErlNifEnv; a2: csize_t): ErlNifTerm","title":"enif_make_uint"},{"location":"bindings/#enif_make_tuple_from_array","text":"proc enif_make_tuple_from_array*(a1: ptr ErlNifEnv; a2: openArray[ErlNifTerm]): ErlNifTerm","title":"enif_make_tuple_from_array"},{"location":"bindings/#enif_make_list_from_array","text":"proc enif_make_list_from_array*(a1: ptr ErlNifEnv; a2: openArray[ErlNifTerm]): ErlNifTerm","title":"enif_make_list_from_array"},{"location":"bindings/#enif_make_new_binary","text":"proc enif_make_new_binary*(a1: ptr ErlNifEnv; a2: csize_t; a3: ptr ErlNifTerm): ptr cuchar","title":"enif_make_new_binary"},{"location":"bindings/#enif_system_info","text":"proc enif_system_info*(a1: ptr ErlNifSysInfo; a2: csize_t): void","title":"enif_system_info"},{"location":"bindings/#enif_system_info_1","text":"proc enif_system_info*(): ErlNifSysInfo","title":"enif_system_info"},{"location":"bindings/#enif_raise_exception","text":"proc enif_raise_exception*(a1: ptr ErlNifEnv; a2: ErlNifTerm): ErlNifTerm","title":"enif_raise_exception"},{"location":"bindings/#enif_has_pending_exception","text":"proc enif_has_pending_exception*(a1: ptr ErlNifEnv; a2: ptr ErlNifTerm): bool","title":"enif_has_pending_exception"},{"location":"bindings/#enif_has_pending_exception_1","text":"proc enif_has_pending_exception*(a1: ptr ErlNifEnv): bool","title":"enif_has_pending_exception"},{"location":"bindings/#enif_term_to_binary","text":"proc enif_term_to_binary*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr ErlNifBinary): cint","title":"enif_term_to_binary"},{"location":"bindings/#enif_binary_to_term","text":"proc enif_binary_to_term*(a1: ptr ErlNifEnv; a2: ptr cuchar; a3: csize_t; a4: ptr ErlNifTerm; a5: csize_t): csize_t","title":"enif_binary_to_term"},{"location":"bindings/#enif_hash","text":"proc enif_hash*(a1: ErlNifHash; term: ErlNifTerm; salt: culonglong = 0): culonglong","title":"enif_hash"},{"location":"bindings/#enif_alloc_env","text":"proc enif_alloc_env*(): ptr ErlNifEnv","title":"enif_alloc_env"},{"location":"bindings/#enif_free_env","text":"proc enif_free_env*(a1: ptr ErlNifEnv)","title":"enif_free_env"},{"location":"bindings/#enif_clear_env","text":"proc enif_clear_env*(a1: ptr ErlNifEnv)","title":"enif_clear_env"},{"location":"bindings/#enif_send","text":"proc enif_send*(a1: ptr ErlNifEnv; a2: ptr ErlNifPid; a3: ptr ErlNifEnv; a4: ErlNifTerm): bool","title":"enif_send"},{"location":"bindings/#enif_make_copy","text":"proc enif_make_copy*(a1: ptr ErlNifEnv; a2: ErlNifTerm): ErlNifTerm","title":"enif_make_copy"},{"location":"bindings/#enif_make_pid","text":"proc enif_make_pid*(a1: ptr ErlNifEnv; a2: ptr ErlNifPid): ErlNifTerm","title":"enif_make_pid"},{"location":"bindings/#enif_self","text":"proc enif_self*(a1: ptr ErlNifEnv; a2: ptr ErlNifPid): ptr ErlNifPid","title":"enif_self"},{"location":"bindings/#enif_get_local_pid","text":"proc enif_get_local_pid*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr ErlNifPid): bool","title":"enif_get_local_pid"},{"location":"bindings/#enif_get_map_size","text":"proc enif_get_map_size*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ptr cuint): bool","title":"enif_get_map_size"},{"location":"bindings/#enif_make_new_map","text":"proc enif_make_new_map*(a1: ptr ErlNifEnv): ErlNifTerm","title":"enif_make_new_map"},{"location":"bindings/#enif_make_map_from_arrays","text":"proc enif_make_map_from_arrays*(a1: ptr ErlNifEnv; a2: ptr ErlNifTerm; a3: ptr ErlNifTerm; a4: cuint, a5: ptr ErlNifTerm): bool","title":"enif_make_map_from_arrays"},{"location":"bindings/#enif_make_map_put","text":"proc enif_make_map_put*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ErlNifTerm; a4: ErlNifTerm; a5: ptr ErlNifTerm): bool","title":"enif_make_map_put"},{"location":"bindings/#enif_get_map_value","text":"proc enif_get_map_value*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ErlNifTerm; a4: ptr ErlNifTerm): bool","title":"enif_get_map_value"},{"location":"bindings/#enif_make_map_update","text":"proc enif_make_map_update*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ErlNifTerm; a4: ErlNifTerm; a5: ptr ErlNifTerm): bool","title":"enif_make_map_update"},{"location":"bindings/#enif_make_map_remove","text":"proc enif_make_map_remove*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: ErlNifTerm; a4: ptr ErlNifTerm): bool","title":"enif_make_map_remove"},{"location":"bindings/#enif_open_resource_type","text":"proc enif_open_resource_type*(a1: ptr ErlNifEnv, a2: typeof(nil); a3: cstring, a4: pointer; a5: ErlNifResourceFlags; a6: ptr ErlNifResourceFlags): ptr ErlNifResourceType","title":"enif_open_resource_type"},{"location":"bindings/#enif_open_resource_type_1","text":"proc enif_open_resource_type*(a1: ptr ErlNifEnv; a2: cstring; a3: ErlNifResourceFlags; a4: ptr ErlNifResourceFlags): ptr ErlNifResourceType","title":"enif_open_resource_type"},{"location":"bindings/#enif_open_resource_type_2","text":"proc enif_open_resource_type*(a1: ptr ErlNifEnv; a2: cstring; a3: ErlNifResourceFlags): ptr ErlNifResourceType","title":"enif_open_resource_type"},{"location":"bindings/#enif_alloc_resource","text":"proc enif_alloc_resource*(a1: pointer; a2: csize_t): pointer","title":"enif_alloc_resource"},{"location":"bindings/#enif_release_resource","text":"proc enif_release_resource*(a1: pointer): void","title":"enif_release_resource"},{"location":"bindings/#enif_make_resource","text":"proc enif_make_resource*(a1: ptr ErlNifEnv; a2: pointer): ErlNifTerm","title":"enif_make_resource"},{"location":"bindings/#enif_get_resource","text":"proc enif_get_resource*(a1: ptr ErlNifEnv; a2: ErlNifTerm; a3: pointer; a4: pointer): bool","title":"enif_get_resource"},{"location":"bindings/#enif_consume_timeslice","text":"proc enif_consume_timeslice*(a1: ptr ErlNifEnv; a2: cint): bool","title":"enif_consume_timeslice"},{"location":"bindings/#enif_schedule_nif","text":"proc enif_schedule_nif*(a1: ptr ErlNifEnv; a2: cstring; a3: cint; a4: NifFunc; a5: cint; a6: ErlNifArgs): ErlNifTerm","title":"enif_schedule_nif"},{"location":"bindings/#enif_schedule_nif_1","text":"proc enif_schedule_nif*(a1: ptr ErlNifEnv; a2: cstring; a3: cint; a4: NifFunc; a5: openArray[ErlNifTerm]): ErlNifTerm","title":"enif_schedule_nif"},{"location":"bindings/#enif_schedule_nif_2","text":"proc enif_schedule_nif*(a1: ptr ErlNifEnv; a2: NifFunc; a3: openArray[ErlNifTerm]): ErlNifTerm","title":"enif_schedule_nif"},{"location":"codec/","text":"Encoding and decoding Erlang terms nimler exposes a set of functions for encoding and decoding Erlang terms. Erlang terms are represented in nimler with the opaque type ErlNifTerm . Available types for codec functions Erlang Elixir nim Encode Decode Integer Integer int, int32, int64, uint, uint32, uint64 \u2713 \u2713 Float Float float, float32, float64 \u2713 \u2713 Atom Atom ErlAtom \u2713 \u2713 String Charlist ErlCharlist \u2713 \u2713 Binary String string \u2713 \u2713 Binary Binary ErlBinary \u2713 \u2713 List List seq \u2713 \u2713 Tuple Tuple tuple \u2713 \u2713 Map Map Table \u2713 \u2713 Encoding Encode nim type to ErlNifTerm let i = 10 var encoded = val . encode ( env ) encoded = 10 'i32 . encode ( env ) # ErlNifTerm(10) Decoding Decode ErlNifTerm to nim type. let i_option = encoded . decode ( env , int32 ) if i_option . isNone (): # The term was not successfully decoded into an int32 else : let i = i_option . get () # i == 10 Note Decoders return a nim Option . Atoms let encoded = ErlAtom ( val : \"test\" ). encode ( env ) # :test let decoded = encoded . decode ( env , ErlAtom ). get () # ErlAtom(val: \"test\") Note The following atom constants are exported from nimler. Note that these are not yet encoded into Erlang terms. AtomOk : ErlAtom(val: \"ok\") AtomErr : ErlAtom(val: \"error\") AtomTrue : ErlAtom(val: \"true\") AtomFalse : ErlAtom(val: \"false\") Strings let encoded = \"test\" . encode ( env ) # \"test\" let decoded = encoded . decode ( env , string ). get () # \"test\" Note Strings are encoded to Erlang binaries. This corresponds to strings in Elixir. Lists let encoded = @[ 1 , 2 , 3 ] . encode ( env ) # [1,2,3] let decoded = encoded . decode ( env , seq [ int ] ). get () # @[1,2,3] Note Erlang lists are decoded to nim seq . In nim, elements of seq must be of the same type. Tuples let encoded = ( \"test\" , 1 , 3.14 ). encode ( env ) # {'test', 1, 3.14} let decoded = encoded . decode ( env , tuple [ a : string , b : int , c : float ] ). get () # (\"test\", 1, 3.14) Note tuples in nim may contain mixed types. Maps import tables var t = initTable [ string , int ] ( 4 ) t [ \"a\" ] = 1 t [ \"b\" ] = 2 let encoded = t . encode ( env ) # %{\"a\" => 1, \"b\" => 2} let decoded = encoded . decode ( env , Table [ string , int ] ). get () # {\"a\": 1, \"b\": 2} Results The ErlResult codec type represents a tuple of arity=2 whose first element is either an atom :ok or :error . nimler also exposes ok() and error() functions for creating terms from either. let term = 1. encode ( env ) let ok_term = term . ok ( env ) # {:ok, 1} let err_term = term . error ( env ) # {:error, 1} Example proxying first argument within a result tuple proc test_nif ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = argv [ 0 ] . ok ( env )","title":"Encoding and decoding Erlang terms"},{"location":"codec/#encoding-and-decoding-erlang-terms","text":"nimler exposes a set of functions for encoding and decoding Erlang terms. Erlang terms are represented in nimler with the opaque type ErlNifTerm .","title":"Encoding and decoding Erlang terms"},{"location":"codec/#available-types-for-codec-functions","text":"Erlang Elixir nim Encode Decode Integer Integer int, int32, int64, uint, uint32, uint64 \u2713 \u2713 Float Float float, float32, float64 \u2713 \u2713 Atom Atom ErlAtom \u2713 \u2713 String Charlist ErlCharlist \u2713 \u2713 Binary String string \u2713 \u2713 Binary Binary ErlBinary \u2713 \u2713 List List seq \u2713 \u2713 Tuple Tuple tuple \u2713 \u2713 Map Map Table \u2713 \u2713","title":"Available types for codec functions"},{"location":"codec/#encoding","text":"Encode nim type to ErlNifTerm let i = 10 var encoded = val . encode ( env ) encoded = 10 'i32 . encode ( env ) # ErlNifTerm(10)","title":"Encoding"},{"location":"codec/#decoding","text":"Decode ErlNifTerm to nim type. let i_option = encoded . decode ( env , int32 ) if i_option . isNone (): # The term was not successfully decoded into an int32 else : let i = i_option . get () # i == 10 Note Decoders return a nim Option .","title":"Decoding"},{"location":"codec/#atoms","text":"let encoded = ErlAtom ( val : \"test\" ). encode ( env ) # :test let decoded = encoded . decode ( env , ErlAtom ). get () # ErlAtom(val: \"test\") Note The following atom constants are exported from nimler. Note that these are not yet encoded into Erlang terms. AtomOk : ErlAtom(val: \"ok\") AtomErr : ErlAtom(val: \"error\") AtomTrue : ErlAtom(val: \"true\") AtomFalse : ErlAtom(val: \"false\")","title":"Atoms"},{"location":"codec/#strings","text":"let encoded = \"test\" . encode ( env ) # \"test\" let decoded = encoded . decode ( env , string ). get () # \"test\" Note Strings are encoded to Erlang binaries. This corresponds to strings in Elixir.","title":"Strings"},{"location":"codec/#lists","text":"let encoded = @[ 1 , 2 , 3 ] . encode ( env ) # [1,2,3] let decoded = encoded . decode ( env , seq [ int ] ). get () # @[1,2,3] Note Erlang lists are decoded to nim seq . In nim, elements of seq must be of the same type.","title":"Lists"},{"location":"codec/#tuples","text":"let encoded = ( \"test\" , 1 , 3.14 ). encode ( env ) # {'test', 1, 3.14} let decoded = encoded . decode ( env , tuple [ a : string , b : int , c : float ] ). get () # (\"test\", 1, 3.14) Note tuples in nim may contain mixed types.","title":"Tuples"},{"location":"codec/#maps","text":"import tables var t = initTable [ string , int ] ( 4 ) t [ \"a\" ] = 1 t [ \"b\" ] = 2 let encoded = t . encode ( env ) # %{\"a\" => 1, \"b\" => 2} let decoded = encoded . decode ( env , Table [ string , int ] ). get () # {\"a\": 1, \"b\": 2}","title":"Maps"},{"location":"codec/#results","text":"The ErlResult codec type represents a tuple of arity=2 whose first element is either an atom :ok or :error . nimler also exposes ok() and error() functions for creating terms from either. let term = 1. encode ( env ) let ok_term = term . ok ( env ) # {:ok, 1} let err_term = term . error ( env ) # {:error, 1} Example proxying first argument within a result tuple proc test_nif ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = argv [ 0 ] . ok ( env )","title":"Results"},{"location":"getting_started/","text":"","title":"Getting started"},{"location":"timeslice/","text":"Cooperating with Erlang scheduler NIFs should return as soon as possible. The threshold for not-quick is around 1ms--although in reality this figure is dynamic. Erlang supports NIFs that take longer to execute--\"dirty\" NIFs--in multiple ways. Identifying NIFs as dirty If a NIF identifies as dirty, Erlang will schedule it separately from normal NIFs. In nimler, dirty functions are specified as in the following example: import os import nimler import nimler / codec proc dirty_cpu ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = for i in 0 .. < 1000 : # do something hard return AtomOk . encode ( env ) proc dirty_io ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = os . sleep ( 1000 ) return AtomOk . encode ( env ) export_nifs ( \"Elixir.NimlerWrapper\" , [ ( \"dirty_cpu\" , 0 , dirty_cpu ). to_nif ( ERL_NIF_DIRTY_CPU ), ( \"dirty_io\" , 0 , dirty_io ). to_nif ( ERL_NIF_DIRTY_IO ) ] )) Note ERL_NIF_DIRTY_CPU and ERL_NIF_DIRTY_IO flags specify whether the function is CPU or IO bound. It's important to classify these right. Per documentation: If you should classify CPU bound jobs as I/O bound jobs, dirty I/O schedulers might starve ordinary schedulers Separating work into multiple NIF calls NIFs can schedule subsequent invocations on the basis of consumed-time. The following function counts to 1000 in 1ms increments. It reschedules itself after it has consumed approximately 10% of a timeslice. proc test_consume_timeslice ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = var i = argv [ 0 ] . decode ( env , int32 ). get ( 0 ) var schedule_count = argv [ 1 ] . decode ( env , int32 ). get ( 0 ) inc ( schedule_count ) while i < 1000 : if enif_consume_timeslice ( env , cint ( 10 )): return enif_schedule_nif ( env , test_consume_timeslice , [ i . encode ( env ), schedule_count . encode ( env ) ] ) os . sleep ( 1 ) inc ( i ) return ( i , schedule_count ). ok ( env ) # {:ok, {1000, 932}} Note enif_consume_timeslice(env, cint): bool takes a % argument and returns true if the NIF has consumed this percent of the timeslice--a timeslice is roughly 1ms. enif_schedule_nif() is used to reschedule the NIF to be called later. This allows the Erlang scheduler to function as normal in the event that other work needs attention.","title":"Cooperating with Erlang scheduler"},{"location":"timeslice/#cooperating-with-erlang-scheduler","text":"NIFs should return as soon as possible. The threshold for not-quick is around 1ms--although in reality this figure is dynamic. Erlang supports NIFs that take longer to execute--\"dirty\" NIFs--in multiple ways.","title":"Cooperating with Erlang scheduler"},{"location":"timeslice/#identifying-nifs-as-dirty","text":"If a NIF identifies as dirty, Erlang will schedule it separately from normal NIFs. In nimler, dirty functions are specified as in the following example: import os import nimler import nimler / codec proc dirty_cpu ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = for i in 0 .. < 1000 : # do something hard return AtomOk . encode ( env ) proc dirty_io ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = os . sleep ( 1000 ) return AtomOk . encode ( env ) export_nifs ( \"Elixir.NimlerWrapper\" , [ ( \"dirty_cpu\" , 0 , dirty_cpu ). to_nif ( ERL_NIF_DIRTY_CPU ), ( \"dirty_io\" , 0 , dirty_io ). to_nif ( ERL_NIF_DIRTY_IO ) ] )) Note ERL_NIF_DIRTY_CPU and ERL_NIF_DIRTY_IO flags specify whether the function is CPU or IO bound. It's important to classify these right. Per documentation: If you should classify CPU bound jobs as I/O bound jobs, dirty I/O schedulers might starve ordinary schedulers","title":"Identifying NIFs as dirty"},{"location":"timeslice/#separating-work-into-multiple-nif-calls","text":"NIFs can schedule subsequent invocations on the basis of consumed-time. The following function counts to 1000 in 1ms increments. It reschedules itself after it has consumed approximately 10% of a timeslice. proc test_consume_timeslice ( env : ptr ErlNifEnv , argc : cint , argv : ErlNifArgs ): ErlNifTerm = var i = argv [ 0 ] . decode ( env , int32 ). get ( 0 ) var schedule_count = argv [ 1 ] . decode ( env , int32 ). get ( 0 ) inc ( schedule_count ) while i < 1000 : if enif_consume_timeslice ( env , cint ( 10 )): return enif_schedule_nif ( env , test_consume_timeslice , [ i . encode ( env ), schedule_count . encode ( env ) ] ) os . sleep ( 1 ) inc ( i ) return ( i , schedule_count ). ok ( env ) # {:ok, {1000, 932}} Note enif_consume_timeslice(env, cint): bool takes a % argument and returns true if the NIF has consumed this percent of the timeslice--a timeslice is roughly 1ms. enif_schedule_nif() is used to reschedule the NIF to be called later. This allows the Erlang scheduler to function as normal in the event that other work needs attention.","title":"Separating work into multiple NIF calls"}]}